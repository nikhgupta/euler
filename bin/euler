#!/usr/bin/env ruby
require 'thor'
require 'euler'

module Euler
  class CLI < Thor
    include Euler::DSL
    include Thor::Actions

    class_option :verbose, type: :boolean, aliases: :v,
                 desc: "be verbose, when possible"

    # downloads (prefetches) problems for offline usage later (caches them)
    # args is specified on CLI using a space separated list of problem ids,
    # which can include ranges (in the form: 31-39)
    # examples of CLI arguments:
    #   euler download 31              # a single problem
    #   euler download 31 35           # multiple problems
    #   euler download 31 35 58-89     # accepts ranges
    #   euler download 23 31,35,58-89  # accepts comma-separated lists
    desc "download ARGS", "download problems for offline use"
    def download(*args)
      # populate problem ids from the passed arguments
      problems = args.parse_as_list

      # ignore: just a formatting routine
      probdis = " " * 14 + problems.map{|a| "%03d" % a}.each_slice(15).
        map{|a| a.join(", ")}.join("\n" + " " * 14)

      say "info", "Problems being downloaded for offline use:\n#{probdis}\n",
          :cyan if options.verbose?

      # if the solved_by stats are old, download fresh
      download_solved_by_stats_if_needed

      batch = []
      problems.each do |id|
        prefetch id
        batch.push "%03d" % id
        if options.verbose?
          message = "Problem: #{"%03d" % id} | #{title_for(id).shorten}"
          say "download", message, :magenta
        elsif batch.length == 10 || id == problems.last
          say "download", "Problems: #{batch.join(", ")}", :magenta
          batch = []
        end
      end

      say "success", "downloaded #{problems.count} problems", :green
    end

    # Prepares a single problem for solving. This method will create
    # a solution file for you, which you can use to readily start solving
    # Euler problems.
    desc "prepare ID", "prepare problem with given ID for solving."
    option :force, type: :boolean, default: false, aliases: :f,
           desc: "overwrite solution file, if it exists"
    def prepare(id)

      download_solved_by_stats_if_needed

      if options.verbose? && !cache.valid?("problem_#{id}")
        say "download", "Problem from Project Euler", :magenta
      end

      @data = prefetch id
      file = solution_file_for id

      if File.exists?(file) && !options.force?
        say "failed", "file already exists", :red
        say "info", "use --force option to overwrite", :cyan if options.verbose?
        say "location", file, :magenta
      else
        template "solution.erb", file
      end
    end

    private

    def download_solved_by_stats_if_needed
      # if the solved_by stats are old, download fresh
      unless cache.valid?("solved_by")
        say "download", "Stats for number of solvers for Euler problems",
            :magenta if options.verbose?
        say "info", "There may be a brief pause.", :cyan
        scraper.fetch_solved_by
      end
    end

    def say(status, message = "", log_status = true)
      @shell ||= Thor::Shell::Color.new
      log_status = false if @options and @options[:quiet]
      @shell.say_status(status, message, log_status)
    end

    def self.source_root
      File.join(File.dirname(File.dirname(__FILE__)), "data")
    end
  end
end

Euler::CLI.start(ARGV)
