#!/usr/env/bin/ruby
# encoding: utf-8

# The Problem: <%= url_for(@data[:id]) %>
# <%= "=" * 76 %>
# <%= @data[:text].break_even(76, "# ") %>
# <%= "=" * 76 %>
# Solved by: <%= @data[:solved_by] %> users.
# Time Spent on Problem: 0 minute.
# Solution Thread: <%= thread_for(@data[:id]) %>
# <%= "=" * 76 %>

require 'euler'

module Euler
  class Solution<%= @data[:id] %> < Base

    def solution_1
    # Step 1: Set settings for this problem in the "environment" method, below.
    # Step 2: Know that, input is available in variable: "@input".
    # Step 3: Start writing your solution..
    end

    def solution_2
    # A second variation of the solution to this problem.
    # This solution can be run by setting: "try_solution 2"
    # inside "environment" method.

    # Delete this method, if not needed, though it wont harm! :)
    end

    def named_solution
    # A third variation of the solution to this problem.
    # This solution can be run by setting: "try_solution 'named_solution'"
    # inside "environment" method.
    end

    def environment
      # ;; this method sets up environment for this problem.
      # ;; you should only set options for this problem here.

      # REGARDING THE INPUT
      # ===================
      # ;; When the input can vary, you can set the default input as:
      # default_input 1_000_000
      # ;; Also, in this case, you are able to add tests, and input checks for the
      # ;; problem. Input checks are simply some arbitrary value of input, you want
      # ;; to check output for.
      # test_case 10, 23
      # check_for 10_000

      # ;; In other cases, the input can be a fixed value due to constraints on the
      # ;; problem or the way the solution has been written. This will help:
      # fixed_input 1_000_000

      # ;; Finally, in some really strange cases, the input is given as a string
      # ;; of data. In these cases, you must manually add one more "#" character
      # ;; in front of the corresponding data (in the problem statement above),
      # ;; and then, use:
      # read_input

      # OTHER THINGS
      # ============
      # ;; Many times, you will want to write more than one approach to
      # ;; a problem, and might want to switch between them from time to time.
      # ;; The following method can be used to randomly switch b/w such methods.
      # try_solution 1
      # ;; The above statement makes Euler think that method with the name
      # ;; "solution_1" is your current approach. If you rather feel savvy, and
      # ;; have defined this approach/method by a custom name, you can pass:
      # try_solution "custom_method_name_for_this_approach"

      # ;; Finally, when you are done solving the problem, please mark it as
      # ;; solved by using the following method:
      # mark_as_solved
    end

  end
end
